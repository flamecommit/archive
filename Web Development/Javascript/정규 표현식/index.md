# 정규 표현식

정규 표현식, 또는 정규식은 문자열에서 특정 문자 조합을 찾기 위한 패턴입니다. JavaScript에서는 정규 표현식도 객체로서, `RegExp`의 `exec()`와 `test()` 메서드를 사용할 수 있습니다. `String`의 `match()`, `matchAll()`, `replace()`, `replaceAll()`, `search()`, `split()` 메서드와도 함께 사용할 수 있습니다. 이 장에서는 JavaScript의 정규 표현식을 설명합니다.

## 정규 표현식 만들기

정규 표현식은 두 가지 방법으로 만들 수 있습니다.

- 정규 표현식 리터럴. 다음과 같이 슬래시로 패턴을 감싸서 작성합니다.

```js
const re = /ab+c/;
```

정규 표현식 리터럴은 스크립트를 불러올 때 컴파일되므로, 파뀔 일이 없는 패턴의 경우 리터럴을 사용하면 성능이 향상될 수 있습니다.

- `RegExp` 객체의 생성자 호출.

```js
const re = new RegExp("ab+c");
```

생성자 함수를 사용하면 정규 표현식이 런타임에 컴파일됩니다. 바뀔 수 있는 패턴이나, 사용자 입력 등 외부 출처에서 가져오는 패턴의 경우 이렇게 사용하세요.

## 정규 표현식 패턴 작성하기

정규 표현식 패턴은 `/abc/`처럼 단순한 문자로 구성하거나, `/ab+c/`와 `/Chapter (\d+)\.\d*/`처럼 단순한 문자와 특수 문자의 조합으로 구성할 수도 있습니다. 특히 `(\d+)`에 나타난 괄호는 정규 표현식에서 기억 장치처럼 쓰여서, 괄호의 안쪽 패턴과 일치한 부분을 나중에 사용할 수 있도록 기억합니다.

### 단순 패턴 사용하기

단순 패턴은 문자열을 있는 그대로 탐색할 때 사용합니다. 예를 들어, `/abc/` 패턴은 문자열에서 정확한 순서로 `"abc"`라는 문자의 조합이 나타나는 부분과 일치합니다. 그러므로 이 패턴은 `"Hi, do you know your abc's?"`와 `"The latest airplane designs evolved from slabcraft."` 두 문자열에서 일치에 성공하고, 일치하는 부분은 `"abc"`일 것입니다. 반면 `"Grab crab"`에서는 일치하지 않는데, 이 문자열은 부분 문자열로 `"abc"`를 포함하긴 하지만, 정확하게 `"abc"`를 포함하지는 않기 때문입니다.

### 특수 문자 사용하기

하나 이상의 "b"를 찾는다거나 공백 문자를 찾는 등 직접적인 일치 이상의 탐색이 필요할 땐 특수 문자를 사용합니다. 예컨데 "하나는 `"a"` 이후에 0개 이상의 `"b"`, 그 뒤의 `"c"`와 일치해야 하면 `/ab*c/` 패턴을 사용할 수 있습니다. `"b"` 뒤의 `*`는 "이전 항목의 0번 이상 반복"을 의미합니다. 이 패턴을 문자열 `"cbbabbbbcdebc"`에 대해 사용하면, 일치하는 부분 문자열은 `"abbbbc"`일 것입니다.

아래의 문서들에선 각각의 범주에 속하는 다양한 특수 문자의 목록과 설명, 예제를 찾아볼 수 있습니다.

- 어서션 - 어서션에는 줄이나 단어의 시작과 끝을 나타내는 경계와, 일치가 가능한 방법을 나타내는 패턴(전방탐색, 후방탐색, 조건 표현식 등)이 포함됩니다.
- 문자 클래스 - 글자와 숫자처럼 다른 유형의 문자를 구분합니다.
- 그룹과 범위 - 표현 문자의 그룹과 범위를 나타냅니다.
- 수량자 - 일치할 문자나 표현이 반복되어야 할 횟수를 나타냅니다.
- 유니코드 속성 이스케이프 - 대/소문자, 수학 기호, 문장 부호처럼, 유니코드 문자 속성에 따라 문자를 구분합니다.

### 이스케이핑

특수 문자를 있는 그대로 탐색(`"*"`을 직접 찾는 등)해야 하는 경우, 특수 문자 앞에 역슬래시(\\)를 배치해서 이스케이프 해야 합니다. 예를 들어 `"a"`뒤의 별표(`"*"`) 뒤의 `"b"`와 일치해야 하면 `"a\\*b/`를 사용하면 됩니다. 역슬래시가 `"*"`를 "이스케이프"해서, 특수 문자가 아닌 문자 리터럴로 취급합니다.

마찬가지로, 슬래시(/)와 일치해야 하는 경우에도 이스케이프를 해야 합니다. 그냥 빗금을 사용하면 패턴이 끝나버립니다. 예를들어 문자열 "/example/"과 그 뒤 하나 이상의 알파벳을 찾으려면 `/\\/example\\/[a-z]/`를 사용할 수 있습니다. 각각의 슬래시 앞에 놓인 역슬래시가 슬래시를 이스케이프합니다.

리터럴 역슬래시에 일치하려면 역슬래시를 이스케이프합니다. "A:\", "B:\", "C:\", ..., "Z:\"와 일치하는 패턴은 `/[A-Z]:\\\\/`입니다. 앞의 역슬래시가 뒤의 역슬래시를 이스케이프해서, 결과적으로 하나의 리터럴 역슬래시와 일치하게 됩니다.

`RegExp` 생성자와 문자열 리터럴을 사용하는 경우, 역슬래시가 문자열 리터럴의 이스케이프로도 작동한다는 것을 기억해야 합니다. 그러므로 정규 표현식의 역슬래시를 나타내려면 문자열 리터럴 수준의 이스케이프도 해줘야 합니다. 즉, 앞서 살펴본 `/a\\*b/` 패턴을 생성하려면 `new RegExp("a\\\\*b")`가 되어야 합니다.

이스케이프 되지 않은 문자열을 이미 가지고 있을 땐 `String.replace`를 활용해 이스케이프를 해줄 수 있습니다.

```js
function escapeRegExp(string) {
    return string.replace(/[.*+?^${}()|[\]\\]/g,"\\$&"); // $&은 일치한 문자열 전체를 의미
}
```

정규 표현식 뒤의 "g"는 전체 문자열을 탐색해서 모든 일치를 반환하도록 지정하는 전역 탐색 플래그입니다.

### 괄호 사용하기

정규 표현식의 아무 부분이나 괄호로 감싸게 되면, 그 부분과 일치하는 부분 문자열을 기억하게 됩니다. 기억한 부분 문자열은 불러와서 다시 사용할 수 있습니다.

## JavaScript에서 정규 표현식 사용하기

정규 표현식은 `RegExp`의 메서드 `test()`와 `exec()`, `String`의 메서드 `match()`, `replace()`, `search()`, `split()`에서 사용할 수 있습니다.

|---|---|
|메서드|설명|
|---|---|
|`exec()`|문자열에서 일치하는 부분을 탐색합니다. 일치 정보를 나타내는 배열, 또는 일치가 없는 경우 `null`을 반환합니다.|
|`test()`|문자열에 일치하는 부분이 있는지 확인합니다. `true`또는 `false`를 반환합니다.|
|`match()`|캡처 그룹을 포함해서 모든 일치를 담은 배열을 반환합니다. 일치가 없으면 `null`을 반환합니다.|
|`matchAll()`|캡처 그룹을 포함해서 모든 일치를 담은 반복기를 반환합니다.|
|`search()`|문자열에서 일치하는 부분을 탐색합니다. 일치하는 부분의 인덱스, 또는 일치가 없는 경우 `-1`을 반환합니다.|
|`replace()`|문자열에서 일치하는 부분을 탐색하고, 그 부분을 대체 문자열로 바꿉니다.|
|`replaceAll()`|문자열에서 일치하는 부분을 모두 탐색하고, 모두 대체 문자열로 바꿉니다.|
|`split()`|정규 표현식 또는 문자열 리터럴을 사용해서 문자열을 부분 문자열의 배열로 나눕니다.|

문자열 내부에 패턴과 일치하는 부분이 존재하는지만 알아내려면 `test()`나 `search()` 메서드를 사용하세요. 더 느리더라도 일치에 관한 추가 정보가 필요하면 `exec()`과 `match()` 메서드를 사용하세요. 일치하는 부분이 존재하면, `exec()`과 `match()`는 일치에 관한 데이터를 포함한 배열을 반환하고, 일치에 사용한 정규 표현식 객체의 속성을 업데이트합니다. 일치하지 못한 경우 `null`을 반환합니다. (`null`은 조건 평가 시 `false`와 같습니다)

아래의 예제에서는, 문자열에서 일치하는 부분을 찾기 위해 `exec()` 메서드를 사용합니다.

```js
const myRe = /d(b+)d/g;
const myArray = myRe.exec("cdbbdbsbz")
```

만약 정규 표현식 객체의 속성에 접근할 필요가 없으면 아래와 같이 짧게 쓸 수도 있습니다.

```js
const myArray = /d(b+)d/g.exec("cdbbdbsbz");
// 'cdbbdbsbz'.match(/d(b+)d/g); 와 비슷하지만,
// 'cdbbdbsbz'.match(/d(b+)d/g)의 반환 값은 [ 'dbbd' ]인 반면
// /d(b+)d/g.exec('cdbbdbsbz')의 반환 값은 [ 'dbbd', 'bb', index: 1, input: 'cdbbdbsbz' ]
```

정규 표현식을 문자열에서 만들고 싶으면 아래처럼 사용할 수도 있습니다.

```js
const myRe = new RegExp("d(b+)d", "g");
const myArray = myRe.exec("cdbbdbsbz");
```

아래의 표는 위 스크립트에서 일치를 성공한 후, 반환하는 배열과 업데이트되는 정규 표현식 객체의 속성입니다.

<table>
  <caption>정규 표현식 실행 결과</caption>
  <thead>
    <tr>
      <th scope="col">객체</th>
      <th scope="col">속성 또는 인덱스</th>
      <th scope="col">설명</th>
      <th scope="col">위 예제에서의 값</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td rowspan="4"><code>myArray</code></td>
      <td></td>
      <td>일치한 문자열 및 기억한 모든 부분 문자열.</td>
      <td><code>['dbbd', 'bb', index: 1, input: 'cdbbdbsbz']</code></td>
    </tr>
    <tr>
      <td><code>index</code></td>
      <td>일치한 부분이 주어진 문자열에서 위치한 인덱스. (0부터 시작)</td>
      <td><code>1</code></td>
    </tr>
    <tr>
      <td><code>input</code></td>
      <td>주어진 원본 문자열.</td>
      <td><code>'cdbbdbsbz'</code></td>
    </tr>
    <tr>
      <td><code>[0]</code></td>
      <td>마지막으로 일치한 부분 문자열.</td>
      <td><code>'dbbd'</code></td>
    </tr>
    <tr>
      <td rowspan="2"><code>myRe</code></td>
      <td><code>lastIndex</code></td>
      <td>
        다음 일치를 시작할 인덱스. (g 옵션을 지정한 정규 표현식의 경우에만 설정됩니다. 플래그를 활용한 고급 탐색을 참고하세요)
      </td>
      <td><code>5</code></td>
    </tr>
    <tr>
      <td><code>source</code></td>
      <td>패턴의 텍스트. 정규 표현식이 생성될 때 갱신됩니다. 실행 시점에는 갱신되지 않습니다.</td>
      <td><code>'d(b+)d'</code></td>
    </tr>
  </tbody>
</table>